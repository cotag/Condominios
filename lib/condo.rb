require 'condo/engine'
require 'condo/application'
require 'condo/errors'


Dir[File.join(File.dirname(__FILE__), 'condo', 'strata', '*.rb')].each do |file|
	require File.basename(file, File.extname(file))
end


module Condo
	
	def self.included(base)
		base.extend ClassMethods
		base.send :include, InstanceMethods
		base.class.set_condo_defaults
	end
	
	
	module InstanceMethods
		
		
		def create
			#
			# Check for existing upload or create a new one
			# => mutually exclusive so can send back either the parts signature from show or a bucket creation signature and the upload_id
			#
			resident = current_resident
			upload = backend.check_exists({
				:user_id => resident,
				:file_name => (instance_eval &@@callbacks[:sanitize_filename]),
				:file_size => params[:upload][:file_size].to_i,
				:file_id => params[:upload][:file_id]
			})
			
			if upload.present?
				residence = set_residence(upload.provider_name, {
					:provider_location => upload.provider_location
					:upload => upload
				})
				
				#
				# Return the parts or direct upload sig
				#
				request = nil
				if upload.resumable_id.present?
					request = residence.get_parts({
						:bucket_name => upload.bucket_name,
						:object_key => upload.object_key,
						:object_options => upload.object_options,
						:resumable_id => upload.resumable_id,
						:params => params[:upload]				# May need to request the next set of parts
					})
				else
					request = residence.new_upload({
						:bucket_name => upload.bucket_name,
						:object_key => upload.object_key,
						:object_options => upload.object_options,
						:file_size => upload.file_size
					})
				end
				
				render :json => request.merge :upload_id => upload.id
			else
				#
				# Create a new upload
				#
				valid, errors = instance_eval &@@callbacks[:pre_validation]		# Ensure the upload request is valid before uploading
				
				
				if !!valid
					set_residence(nil) if @@callbacks[:dynamic_residence].present?
					residence = current_residence
					
					#
					# Build the request
					#
					request = residence.new_upload(params[:upload].merge {
						:bucket_name => (instance_eval &@@callbacks[:bucket_name]),			# Allow the application to define a custom bucket name
						:object_key => (instance_eval &@@callbacks[:object_key]),			# The object key should also be generated by the application
						:object_options => (instance_eval &@@callbacks[:object_options])	# Do we want to mess with any of the options?
					})
					
					#
					# Save a reference to this upload in the database
					# => This should throw an error on failure
					#
					upload = backend.add_entry(params[:upload].merge :provider_name => residence.name, :provider_location => residence.location)
					render :json => request.merge :upload_id => upload.id
					
				elsif errors.is_a Hash
					render :json => errors, :status => :not_acceptable
				else
					render :nothing => true, :status => :not_acceptable
				end
			end
		end
		
		
		#
		# Authorisation check all of these
		#
		def edit
			#
			# Get the signature for parts + final commit
			#
			upload = current_upload
			
			if upload.resumable_id.present?
				residence = set_residence(upload.provider_name, {:location => upload.provider_location, :upload => upload})
				
				request = residence.set_part({
					:bucket_name => upload.bucket_name,
					:object_key => upload.object_key,
					:object_options => upload.object_options,
					:resumable_id => upload.resumable_id,
					:part => params[:part]						# part may be called 'finish' for commit signature
				})
				
				render :json => request.merge :upload_id => upload.id
			else
				render :nothing => true, :status => :not_acceptable
			end
		end
		
		
		def update
			#
			# Provide the upload id after creating a resumable upload (may not be completed)
			# => We then provide the first part signature
			#
			# OR
			#
			# Complete an upload
			#
			if params[:resumable_id]
				upload = current_upload
				@current_upload = backend.update_entry :upload_id => params[:upload_id], :resumable_id => params[:resumable_id]
				edit
			else
				response = instance_exec current_upload, &@@callbacks[:upload_complete]
				if !!response
					backend.remove_entry :upload_id => params[:upload_id]
					render :json => {:upload_id => upload.id}
				else
					render :nothing => true, :status => :not_acceptable
				end
			end
		end
		
		
		def destroy
			#
			# Delete the file from the cloud system - the client is not responsible for this
			#
			response = instance_exec current_upload, &@@callbacks[:destroy_upload]
			if !!response
				backend.remove_entry :upload_id => params[:upload_id]
				render :json => {:upload_id => upload.id}
			else
				render :nothing => true, :status => :not_acceptable
			end
		end
		
		
		protected
		
		
		#
		# A before filter can be used to select the cloud provider for the current user
		# 	Otherwise the dynamic residence can be used when users are define their own storage locations
		#
		def set_residence(name, options = {})
			if @@callbacks[:dynamic_residence].present? && (!!!options[:dynamic])
				if options[:upload].present?
					upload = options[:upload]
					instance_exec {
						:user_id => current_resident,
						:file_name => upload.file_name,
						:file_size => upload.file_size,
						:custom_params => upload.custom_params,
						:provider_name => upload.provider_name,
						:provider_location => upload.provider_location
					}, &@@callbacks[:dynamic_residence]
				else
					instance_exec {
						:user_id => current_resident,
						:file_name => params[:upload][:file_name],
						:file_size => params[:upload][:file_size],
						:custom_params => params[:upload][:custom_params]
					}, &@@callbacks[:dynamic_residence]
				end
			else
				if !!options[:dynamic]
					@current_residence = "Condo::Strata::#{name.to_s.camelize}".constantize.new(options)
				else
					@current_residence = options[:location].present? ? @@locations[name.to_sym][options[:location]] : @@locations[name.to_sym][:default]
				end
			end
			
			@current_residence
		end
		
		def current_residence
			@current_residence ||= @@residencies[0]
		end
		
		def current_upload
			@current_upload ||= backend.check_exists({:user_id => current_resident, :upload_id => params[:upload_id]}).tap do |object|	#current_residence.name && current_residence.location && resident.id.exists?
				raise Condo::Errors::NotYourPlace unless object.present?
			end
		end
		
		def current_resident
			@current_resident ||= (instance_eval &@@callbacks[:resident_id]).tap do |object|	# instance_exec for params
				raise Condo::Errors::LostTheKeys unless object.present?
			end
		end
		
		def backend
			Condo::Application.backend
		end
	end
	
	
	
	module ClassMethods
		
		protected
		
		
		def add_residence(name, options = {})
			@@residencies ||= []
			@@residencies << ("Condo::Strata::#{name.to_s.camelize}".constantize.new(options)).tap do |res|
				name = name.to_sym
				
				@@locations ||= {}
				@@locations[name] ||= {}
				if options[:location].present?
					@@locations[name][options[:location]] = res
				else
					@@locations[name][:default] = res
				end
			end
		end
		
		
		def set_callback(name, callback = nil, &block)
			if callback.is_a(Proc)
				@@callbacks[name.to_sym] = callback
			elsif block.present?
				@@callbacks[name.to_sym] = block
			else
				raise ArgumentError, 'Condo callbacks must be defined with a Proc or Proc (lamba) object present'
			end
		end
		
		
		#
		# Defines the default callbacks
		#
		def set_condo_defaults
			(@@callbacks ||= {}).merge {
				#:resident_id		# Must be defined by the including class
				:bucket_name => proc {"#{Rails.application.class.parent_name}#{instance_eval @@callbacks[:resident_id]}"},
				:object_key => proc {params[:upload][:file_name]},
				:object_options => proc {{:permissions => :private}},
				:pre_validation => proc {true},	# To respond with errors use: lambda {return false, {:errors => {:param_name => 'wtf are you doing?'}}}
				:sanitize_filename => proc {
					params[:upload][:file_name].tap do |filename|
						filename.gsub!(/^.*(\\|\/)/, '')	# get only the filename (just in case)
						filename.gsub!(/[^\w\.\-]/,'_')		# replace all non alphanumeric or periods with underscore
					end
				}
				#:upload_complete	# Must be defined by the including class
				#:destroy_upload	# the actual delete should be done by the application
				#:dynamic_residence	# If the data stores are dynamically stored by the application
			}
		end
		
	end
	

end
